<!doctype html>
<html>
  <head>
    <title>API Performance Benchmark</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 20px auto;
        padding: 0 20px;
      }
      .controls {
        margin: 20px 0;
      }
      .results {
        margin-top: 20px;
      }
      .chart {
        margin-top: 20px;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 20px;
      }
      .stat-card {
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #f9f9f9;
      }
      progress {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>API Performance Benchmark</h1>

    <div class="controls">
      <label
        >Количество итераций:
        <input type="number" id="iterations" value="20" min="1" max="100"
      /></label>
      <button onclick="runBenchmark()" id="startButton">Запустить тест</button>
    </div>

    <div class="results">
      <h3>Прогресс</h3>
      <progress id="progressBar" value="0" max="100"></progress>
      <div id="currentOperation"></div>

      <div class="stats" id="stats"></div>
      <div class="chart" id="chart"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script>
      let chart = null;

      // Функция для очистки кэша через временный fetch
      const clearCache = async () => {
        try {
          await fetch("https://pokeapi.co/api/v2/pokemon/1", {
            cache: "no-store",
          });
        } catch (e) {
          console.error("Error clearing cache:", e);
        }
      };

      // Функция для случайной задержки
      const randomDelay = () => {
        const delay = Math.floor(Math.random() * 1000) + 500; // 500-1500ms
        return new Promise((resolve) => setTimeout(resolve, delay));
      };

      // Функция замера времени выполнения
      const timeFunction = async (fn) => {
        const start = performance.now();
        await fn();
        return performance.now() - start;
      };

      // Единый запрос
      const fetchAllAtOnce = async () => {
        try {
          const response = await fetch(
            "https://pokeapi.co/api/v2/pokemon?limit=100",
            {
              cache: "no-store",
            },
          );
          const data = await response.json();
          return data.results.length;
        } catch (error) {
          console.error("Error in single fetch:", error);
          throw error;
        }
      };

      // Батчевые запросы
      const fetchInBatches = async () => {
        const batchSize = 10;
        const batches = [];

        try {
          for (let i = 0; i < 10; i++) {
            const offset = i * batchSize;
            batches.push(
              fetch(
                `https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${batchSize}`,
                {
                  cache: "no-store",
                },
              ).then((response) => response.json()),
            );
          }

          const results = await Promise.all(batches);
          return results.reduce((acc, batch) => acc + batch.results.length, 0);
        } catch (error) {
          console.error("Error in batch fetch:", error);
          throw error;
        }
      };

      // Вычисление статистики
      const calculateStats = (times) => {
        const sorted = [...times].sort((a, b) => a - b);
        return {
          min: sorted[0].toFixed(2),
          max: sorted[sorted.length - 1].toFixed(2),
          median: sorted[Math.floor(sorted.length / 2)].toFixed(2),
          average: (times.reduce((a, b) => a + b) / times.length).toFixed(2),
          total: times.reduce((a, b) => a + b).toFixed(2),
        };
      };

      // Обновление UI
      const updateStats = (singleStats, batchStats) => {
        const statsDiv = document.getElementById("stats");
        statsDiv.innerHTML = `
                <div class="stat-card">
                    <h3>Единый запрос (мс)</h3>
                    <p>Среднее: ${singleStats.average}</p>
                    <p>Медиана: ${singleStats.median}</p>
                    <p>Мин: ${singleStats.min}</p>
                    <p>Макс: ${singleStats.max}</p>
                    <p>Всего: ${singleStats.total}</p>
                </div>
                <div class="stat-card">
                    <h3>Батчевые запросы (мс)</h3>
                    <p>Среднее: ${batchStats.average}</p>
                    <p>Медиана: ${batchStats.median}</p>
                    <p>Мин: ${batchStats.min}</p>
                    <p>Макс: ${batchStats.max}</p>
                    <p>Всего: ${batchStats.total}</p>
                </div>
            `;

        if (chart) {
          chart.destroy();
        }

        const ctx = document.createElement("canvas");
        document.getElementById("chart").innerHTML = "";
        document.getElementById("chart").appendChild(ctx);

        chart = new Chart(ctx, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "Единый запрос",
                data: singleTimes.map((time, index) => ({
                  x: index + 1,
                  y: time,
                })),
                backgroundColor: "rgb(75, 192, 192)",
              },
              {
                label: "Батчевые запросы",
                data: batchTimes.map((time, index) => ({
                  x: index + 1,
                  y: time,
                })),
                backgroundColor: "rgb(255, 99, 132)",
              },
            ],
          },
          options: {
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Время выполнения (мс)",
                },
              },
              x: {
                title: {
                  display: true,
                  text: "Номер итерации",
                },
              },
            },
            plugins: {
              title: {
                display: true,
                text: "Результаты тестирования",
              },
            },
          },
        });
      };

      let singleTimes = [];
      let batchTimes = [];

      const updateProgress = (current, total) => {
        const progress = (current / total) * 100;
        document.getElementById("progressBar").value = progress;
      };

      const updateCurrentOperation = (message) => {
        document.getElementById("currentOperation").textContent = message;
      };

      const runBenchmark = async () => {
        const iterations = parseInt(
          document.getElementById("iterations").value,
        );
        const startButton = document.getElementById("startButton");
        startButton.disabled = true;
        singleTimes = [];
        batchTimes = [];

        try {
          for (let i = 0; i < iterations; i++) {
            updateProgress(i, iterations * 2);

            // Единый запрос
            updateCurrentOperation(
              `Итерация ${i + 1}/${iterations}: Единый запрос`,
            );
            await clearCache();
            await randomDelay();
            const singleTime = await timeFunction(fetchAllAtOnce);
            singleTimes.push(singleTime);

            // Батчевые запросы
            updateCurrentOperation(
              `Итерация ${i + 1}/${iterations}: Батчевые запросы`,
            );
            await clearCache();
            await randomDelay();
            const batchTime = await timeFunction(fetchInBatches);
            batchTimes.push(batchTime);

            // Обновляем статистику после каждой итерации
            updateStats(
              calculateStats(singleTimes),
              calculateStats(batchTimes),
            );
          }

          updateProgress(iterations * 2, iterations * 2);
          updateCurrentOperation("Тестирование завершено");
        } catch (error) {
          updateCurrentOperation(`Ошибка: ${error.message}`);
        } finally {
          startButton.disabled = false;
        }
      };
    </script>
  </body>
</html>
